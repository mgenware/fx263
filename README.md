# mingru (WIP)

[![MEAN Module](https://img.shields.io/badge/MEAN%20Module-TypeScript-blue.svg?style=flat-square)](https://github.com/mgenware/MEAN-Module)
[![Build Status](https://img.shields.io/travis/mgenware/mingru.svg?style=flat-square&label=Build+Status)](https://travis-ci.org/mgenware/mingru)
[![npm version](https://img.shields.io/npm/v/mingru.svg?style=flat-square)](https://npmjs.com/package/mingru)
[![Node.js Version](http://img.shields.io/node/v/mingru.svg?style=flat-square)](https://nodejs.org/en/)

Convert [dd-models](https://github.com/mgenware/dd-models) to Go code.

Goals:

* **No performance penalty at runtime**, SQL builder, not an ORM
* **Strongly typed models**, models are defined in TypeScript not Go
* Currently focuses on Go and MySQL/MariaDB

See [FAQ](#faq) below for more details.

## Example

### Step 1: Define your models

For example, let's define a simple user table with 3 columns using [dd-models](https://github.com/mgenware/dd-models):

```ts
// ----------- user table model (user.ts) -----------
import * as dd from 'dd-models';

class User extends dd.Table {
  id = dd.pk();
  name = dd.varChar(100);
  sig = dd.text().nullable;
  age = dd.int();
}

export default dd.table(User);
```

### Step 2: Define you actions

Let's import the user table (`user.ts`) above, and add some CRUD actions:

```ts
// ----------- user table actions (userTA.ts) -----------
import * as dd from 'dd-models';
import user from './user';

const userTA = dd.actions(user);
// Select a user profile by ID
userTA.select('UserProfile', user.id, user.name, user.sig).byID();
// Select all user profiles
userTA.selectAll('AllUserProfiles', user.id, user.name, user.sig);
// Select the single sig field by ID
userTA.selectField('Sig', user.sig).byID();

// Update an user profile by ID
userTA
  .updateOne('UserProfile')
  .setInputs(user.name, user.sig)
  .byID();

// Update all user.sig to an empty string
userTA.updateAll('AllSigToEmpty').set(user.sig, dd.sql`''`);

// Delete an user by ID
userTA.deleteOne('ByID').byID();

// Delete all users by a specified name
userTA.delete('ByName').where(user.name.isEqualToInput());

// Delete all users
userTA.deleteAll('All');

// Insert a new user
userTA
  .insertOne('User')
  .set(user.sig, dd.sql`''`)
  .setInputs(user.name, user.age);

export default userTA;
```

### Step 3: Generate the Go Code
The following is the Go code generated by mingru from the actions above (function bodies are omitted for simplicity):

```go
 /******************************************************************************************
 * This code was automatically generated by mingru (https://github.com/mgenware/mingru)
 * Do not edit this file manually, your changes will be overwritten.
 ******************************************************************************************/

package da

import (
	"github.com/mgenware/go-packagex/dbx"
)

// TableTypeUser ...
type TableTypeUser struct {
}

// User ...
var User = &TableTypeUser{}

// ------------ Actions ------------

// UserTableSelectUserProfileResult ...
type UserTableSelectUserProfileResult struct {
	ID   uint64
	Name string
	Sig  *string
}

// SelectUserProfile ...
func (da *TableTypeUser) SelectUserProfile(queryable dbx.Queryable, id uint64) (*UserTableSelectUserProfileResult, error) {
	result := &UserTableSelectUserProfileResult{}
	err := queryable.QueryRow("SELECT `id`, `name`, `sig` FROM `user` WHERE `id` = ?", id).Scan(&result.ID, &result.Name, &result.Sig)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// UserTableSelectAllUserProfilesResult ...
type UserTableSelectAllUserProfilesResult struct {
	ID   uint64
	Name string
	Sig  *string
}

// SelectAllUserProfiles ...
func (da *TableTypeUser) SelectAllUserProfiles(queryable dbx.Queryable) ([]*UserTableSelectAllUserProfilesResult, error) {
	rows, err := queryable.Query("SELECT `id`, `name`, `sig` FROM `user`")
	if err != nil {
		return nil, err
	}
	result := make([]*UserTableSelectAllUserProfilesResult, 0)
	defer rows.Close()
	for rows.Next() {
		item := &UserTableSelectAllUserProfilesResult{}
		err = rows.Scan(&item.ID, &item.Name, &item.Sig)
		if err != nil {
			return nil, err
		}
		result = append(result, item)
	}
	err = rows.Err()
	if err != nil {
		return nil, err
	}
	return result, nil
}

// SelectSig ...
func (da *TableTypeUser) SelectSig(queryable dbx.Queryable, id uint64) (*string, error) {
	var result *string
	err := queryable.QueryRow("SELECT `sig` FROM `user` WHERE `id` = ?", id).Scan(&result)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// UpdateUserProfile ...
func (da *TableTypeUser) UpdateUserProfile(queryable dbx.Queryable, id uint64, name string, sig *string) error {
	result, err := queryable.Exec("UPDATE `user` SET `name` = ?, `sig` = ? WHERE `id` = ?", name, sig, id)
	return dbx.CheckOneRowAffectedWithError(result, err)
}

// UpdateAllSigToEmpty ...
func (da *TableTypeUser) UpdateAllSigToEmpty(queryable dbx.Queryable) (int, error) {
	result, err := queryable.Exec("UPDATE `user` SET `sig` = ''")
	return dbx.GetRowsAffectedIntWithError(result, err)
}

// DeleteByID ...
func (da *TableTypeUser) DeleteByID(queryable dbx.Queryable, id uint64) error {
	result, err := queryable.Exec("DELETE FROM `user` WHERE `id` = ?", id)
	return dbx.CheckOneRowAffectedWithError(result, err)
}

// DeleteByName ...
func (da *TableTypeUser) DeleteByName(queryable dbx.Queryable, name string) (int, error) {
	result, err := queryable.Exec("DELETE FROM `user` WHERE `name` = ?", name)
	return dbx.GetRowsAffectedIntWithError(result, err)
}

// DeleteAll ...
func (da *TableTypeUser) DeleteAll(queryable dbx.Queryable) (int, error) {
	result, err := queryable.Exec("DELETE FROM `user`")
	return dbx.GetRowsAffectedIntWithError(result, err)
}

// InsertUser ...
func (da *TableTypeUser) InsertUser(queryable dbx.Queryable, name string, age int) (uint64, error) {
	result, err := queryable.Exec("INSERT INTO `user` (`sig`, `name`, `age`) VALUES ('', ?, ?)", name, age)
	return dbx.GetLastInsertIDUint64WithError(result, err)
}
```

### Step 4: Using the generated code in your Go project

```go
func main() {
	// Open a DB connection on localhost
	db, err := sql.Open("mysql", "root:123456@/test")
	if err != nil {
		panic(err)
	}

	// Select all user profiles
	users, err := da.User.SelectAllUserProfiles(db)
	if err != nil {
		panic(err)
	}

	// Loop through the result
	for _, user := range users {
		fmt.Printf("ID: %v, Name: %v, Sig: %v\n", user.ID, user.Name, user.Sig)
	}
}
```



## Usage

### Defining Models

mingru converts [dd-models](https://github.com/mgenware/dd-models) to Go code, to learn how to define models, refer to [dd-models docs](https://github.com/mgenware/dd-models).

### Generating Go Code

Once you are familiar with [dd-models](https://github.com/mgenware/dd-models), you can import your actions, and use `mingru.build` along with a dialect to generate Go code:

```ts
function build(
  // An array of dd-models table actions
  tableActionList: dd.TableActionCollection[],
  // A dialect object, currently, only MySQL is supported
  dialect: Dialect,
  // The output directory where Go files are written to
  outDir: string,
  // Extra options
  options?: IBuildOption,
): Promise<void>;
```

Example:

```ts
// mingru.ts
import * as mr from 'mingru';
// Import your model actions
import userTA from './models/userTA';

(async () => {
  const actions = [userTA];
  const dialect = new mr.MySQL();
  // Build Go code to '../da/` directory
  await mr.build(actions, dialect, '../da/');
})();
```

It's also recommended to use `ts-node` and add build command to `package.json` scripts section:

```json
{
  "scripts": {
    "build": "ts-node mingru.ts"
  },
}
```

Now you can build your project using `yarn build`.

### More examples
For a more detailed and runnable example, visit [mingru-go-example](https://github.com/mgenware/mingru-go-example)

## FAQ

### Why rely on Node.js/TypeScript? why not use Go to generate Go code?

The problem of Go is, it cannot offer a way to declare models in a strongly typed way, for example, this is how a model typically looks like in a Go-based library:

```go
type User struct {
  lib.Model           `table:"users"`
  ID        int64     `pk:"autoincr"`
  Username  string
  Email     string
  Password  string
  CreatedAt time.Time
}
```

It uses Go struct field tags to inject model info, thus tends to be error-prone. Below is the code for defining models in mingru using TypeScript, everything is strongly typed:

```ts
import * as dd from 'dd-models';

class User extends dd.Table {
  id = dd.pk();
  name = dd.varChar(100);
  sig = dd.text().nullable;
}

export default dd.table(User);
```
